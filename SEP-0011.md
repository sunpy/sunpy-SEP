# SEP-0011 -- Standards, Tools and Workflows for SunPy Project packages #

| SEP           | 11                                                           |
|---------------|--------------------------------------------------------------|
| title         | Standards, Tools and Workflows for SunPy Project packages    |
| author(s)     | Nabil Freij                                                  |
| contact email | <nabil.freij@gmail.com>                                      |
| date-creation | Before The Big Bang                                          |
| type          | standard                                                     |
| discussion    | No one said anything                                         |
| status        | accepted                                                     |

## Introduction ##

As the SunPy Project has grown, the number of packages under its control has increased with plans to increase this further to fill the gaps within the SunPy ecosystem.
As the maintainers of these packages are not all the same, they have different ideas on how to develop, package and release their packages.
This has led to a divergence in the tools, workflows and standards that each package follows.

This SEP aims to unify these and provide a clear set of guidelines for all packages under the SunPy Project to follow.
The end goal is to provide a outline for the new package template to adopt which we can roll out to all existing and future repositories.
Furthermore, to aid the recruitment of new maintainers, we hope that this SEP will provide a clear set of guidelines for them to follow as well as the reasons behind them.

## Code Standards ##

The goal of the SunPy Project has always been to follow the wider Python Community and use their standards.
This has been informal and was applied based on how NumPy or SciPy did it at the time one of the Project members checked.
More recently, this has become more formal for the Scientific Python Community with the creation of the [Scientific Python Project](https://scientific-python.org/).
While it is still in its infancy, they have been attempting to document and standardize the tools and workflows used by that community using their own [PEP style documents](https://scientific-python.org/specs/).
As this does not cover many of the topics this SEP aims to cover, we will not be using it as a reference.

For now, we have alwayws been trying to follow the [PEP 8](https://peps.python.org/pep-0008/) style but recently, the [Black](https://github.com/psf/black) style has become the informal standard within this space.
This is a big change from the PEP 8 style (even if it is a PEP8 compliant) and has caused uproar in other communities.
We plan to move towards the Black style in the future but for now, we will continue to use the PEP 8 style.

When it comes to code standards aka best practices, this is where [ruff](https://github.com/astral-sh/ruff) comes in.
It's goal is to subsume all the other linting tools and provide a single tool to check all the code standards within the Python ecosystem.
This means eventually replacing flake8, pylint, etc with a single fast tool.
However, this comes with its own burden of having to configure such a complex tool.

The aim is to find the rules that ruff wants to enforce which we as a community disagree on, so that we can disable those checks but with the goal being to enable as many rules as possible.
This will be a slow process as many of our libraries are very large which means they have a lot of code which may need to be fixed to follow the over 700 rules that ruff provides.
As ruff can only autofix some of these rules, it will be a slow process of enabling rules, fixing the code and then enabling more rules on all existing packages.
For new packages, we would enable them from the start.

Summary:

1. Create a ruff configuration file that can be used by all packages.
2. Enable this configuration file on all existing packages and slowly fix the code to follow the rules.
3. Use ruff to format code to follow the black style once we asked the community.

## Tools ##

In addition to code standards, we also need to standardize the tools used to develop, package and release packages.
This means the testing frameworks, documentation tools and linters (covered above).
We want to reduce the burden on maintainers, so desire that any tools we use are simple to wield and configure.
Ideally auto fixing where possible.

With this in mind, we want to use the following tools:

1. [pytest](https://docs.pytest.org/en/stable/) for testing.
   This has become the defacto standard for testing in the Python community, it supports many plugins to extend its functionality and is easy to use.
2. [sphinx](https://www.sphinx-doc.org/en/master/) for documentation.
    This is the standard tool for documentation in the ScientiÔ¨Åc Python community.
    This does mean that documentation should be written in the reStructuredText format.
3. [tox](https://tox.readthedocs.io/en/latest/) for isolated build and test environments.
   This allows us to script the creation of isolated environments and run arbitrary commands within them.
   As a result it is used to run the test suite, the linting tools and to build the sphinx documentation.
   This ensures that all of these tools are run in the same environment (no matter the system, to a point) and that the environment is isolated from the rest of the system.
4. [pre-commit](https://pre-commit.com/) for running linting tools.
   While this directly does not do any linting or formatting, it allows us to run linting tools with our configuration.
   This can be installed locally as a git hook for maintainers to use.
   It's biggest advantage is that it can be used with its online service, [pre-commit.ci](https://pre-commit.ci/) which allows us to ensure that all code is to standard and can be used to fix any problems with a comment.
   The exact configuration of this tool is still to be determined but will not be covered by this SEP as these tools are still in flux.
5. [ReadTheDocs](https://readthedocs.org/).
   This is where our documentation is hosted and will continue to be hosted.
   It stands as currently the only tool that can host documentation for multiple versions of a package as well.

## Build System ##

For the longest time, we have used [setuptools](https://setuptools.pypa.io/en/latest/) to build our packages.
This came in the form of ``setup.py`` files with optional `setup.cfg` files containing the package metadata.

However, [PEP 517 and PEP 518](https://peps.python.org/pep-0517/) have introduced a new way to specify this, using a `pyproject.toml` file.
This file contains the build system configuration and is used by many other non-setuptools build backends.

The goal is to move to towards supporting **only** the `pyproject.toml` file in the future and **not** move from using setuptools.

The one notable downside to setuptools is that it's support for non C/C++ extensions (especially fortran) are either non-existent or rudimentary.
So far, the SunPy Project has not had to deal with this case but it is something to keep in mind.

Summary:

1. Move to `pyproject.toml` for build system configuration and package metadata.
2. Use setuptools for now, until the need for a more powerful build system arises.

## Implementation ##

The question to follow up is how do we implement this?
The answer is to use a combination of the [sunpy-package-template](https://github.com/sunpy/package-template) and [cruft](https://cruft.github.io/cruft/) (this tool could change in the future).
This will allow us to create a template that can be used to create new packages and also update existing packages to the new standards.

So any action items above would be implemented within the package template repository and then rolled out to all existing packages.

## Caveats ##

There are three(?) massive omissions from this SEP:

1. The lack of type checking.
   While the broader Python community has been moving towards type checking, as a community we have not.
   Partly this is due our close integration with Astropy which has not adopted type checking and would need to do so, before we could.
   The other is that Stuart hates it even though it makes things better for everyone since its "ugly".
   This is something that we should revisit in the future.
2. Continuous Integration (CI).
   We use a range of CI providers and we have been forced to move depending changes from these providers.
   So we will avoid the naming of any provider in this SEP.
3. Usage of [GitHub](https://github.com/).
   While we have been using [GitHub](https://github.com/) for a long time and moving away from it would be a massive undertaking, it is not the only provider.
